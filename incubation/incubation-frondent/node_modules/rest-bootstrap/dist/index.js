"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serve = void 0;
const express = require("express");
const bodyParser = require("body-parser");
const Injector_1 = require("./Injector");
__exportStar(require("./Decorators"), exports);
__exportStar(require("./errors/BadRequestError"), exports);
__exportStar(require("./errors/ForbiddenError"), exports);
__exportStar(require("./errors/HttpError"), exports);
__exportStar(require("./errors/InternalServerError"), exports);
__exportStar(require("./errors/NotFoundError"), exports);
__exportStar(require("./errors/UnauthorizedError"), exports);
__exportStar(require("./errors/ValidationError"), exports);
const defaultMiddleware = [
    bodyParser.urlencoded({ extended: true }),
    bodyParser.json(),
];
const defaultErrorHandler = (err, req, res, next) => {
    res.status(err.code || 500).send(err);
};
exports.serve = (application, port, callback) => {
    const app = express();
    const applicationInstance = new application();
    const injector = new Injector_1.Injector();
    if (applicationInstance.services) {
        applicationInstance.services.forEach((service) => __awaiter(void 0, void 0, void 0, function* () {
            const serviceInstance = injector.resolve(service);
            if (typeof serviceInstance.init === 'function') {
                yield serviceInstance.init();
            }
        }));
    }
    // Register global middleware
    const globalMiddleware = [...defaultMiddleware];
    if (applicationInstance.middleware) {
        applicationInstance.middleware.forEach(middleware => {
            const middlewareInstance = injector.resolve(middleware);
            globalMiddleware.push(middlewareInstance.handle.bind(middlewareInstance));
        });
    }
    globalMiddleware.forEach(middleware => {
        app.use(middleware);
    });
    // Register controllers
    applicationInstance.controllers.forEach(controller => {
        const controllerInstance = injector.resolve(controller);
        const router = express.Router();
        const prefix = Reflect.getMetadata('prefix', controller) || '';
        const routes = Reflect.getMetadata('routes', controller) || [];
        routes.forEach(route => {
            if (!route.requestMethod || !route.path || !route.handler) {
                return;
            }
            const routeMiddleware = [];
            // Register route middleware
            if (route.middleware) {
                route.middleware.forEach(middleware => {
                    const middlewareInstance = injector.resolve(middleware);
                    const asyncHandler = (req, res, next) => __awaiter(void 0, void 0, void 0, function* () {
                        try {
                            yield middlewareInstance.handle(req, res, next);
                        }
                        catch (e) {
                            next(e);
                        }
                    });
                    routeMiddleware.push(asyncHandler);
                });
            }
            const params = Reflect.getMetadata('params', controllerInstance, route.handler) || [];
            // Register route handler
            router[route.requestMethod](route.path, routeMiddleware, (req, res, next) => __awaiter(void 0, void 0, void 0, function* () {
                const extractedParams = params.map((param) => {
                    if (param.type === 'request') {
                        return req;
                    }
                    else if (param.type === 'response') {
                        return res;
                    }
                    else if (param.type === 'param') {
                        if (param.name) {
                            return req.params[param.name];
                        }
                        else {
                            return req.params;
                        }
                    }
                    else if (param.type === 'body') {
                        if (param.name) {
                            return req.body[param.name];
                        }
                        else {
                            return req.body;
                        }
                    }
                    else if (param.type === 'query') {
                        if (param.name) {
                            return req.query[param.name];
                        }
                        else {
                            return req.query;
                        }
                    }
                    else if (param.type === 'header') {
                        if (param.name) {
                            return req.headers[param.name];
                        }
                        else {
                            return req.headers;
                        }
                    }
                });
                try {
                    const results = yield controllerInstance[String(route.handler)](...extractedParams);
                    res.send(results);
                }
                catch (e) {
                    next(e);
                }
            }));
        });
        app.use(prefix, router);
    });
    let errorHandler = defaultErrorHandler;
    if (applicationInstance.errorHandler) {
        const errorHandlerInstance = injector.resolve(applicationInstance.errorHandler);
        errorHandler = errorHandlerInstance.handle.bind(errorHandlerInstance);
    }
    app.use(errorHandler);
    return app.listen(port, callback);
};
//# sourceMappingURL=index.js.map